// Boost.Geometry

// Contributed and/or modified by Adeel Ahmad.

// Use, modification and distribution is subject to the Boost Software License,
// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
#define BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

#include <boost/geometry/util/math.hpp>

namespace boost { namespace geometry { namespace series_expansion {

    /*
     Generate and evaluate the series expansion of the following integral

     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )

     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2
     and expand (1 - eps) * I1 retaining terms up to order eps^maxpow
     in A1 and C1[l].

     The resulting series is of the form

     A1 * ( sigma + sum(C1[l] * sin(2*l*sigma), l, 1, maxpow) ).

     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_series_A1 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        taylordepth:5$
        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$
        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],
        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$

        computeI1(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],
          sintegrand:sqrt(1+k2*sin(sigma)^2),
          sintegrandexp:ataylor(
              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),
              eps,maxpow),
          s:trigreduce(integrate(sintegrandexp,sigma)),
          s:s-subst(sigma=0,s),
          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),
          tau1:ataylor(s/A1,eps,maxpow),
          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),
          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0
          then error("left over terms in B1"),
          A1:A1/(1-eps),
          'done)$

        codeA1(maxpow):=block([tab2:"    ",tab3:"        "],
        print("// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1
        static inline CT evaluate_series_A1(CT eps) {
            CT eps2 = math::sqr(eps);
            CT t;
            switch (SeriesOrder/2) {"),
          for n:0 thru entier(maxpow/2) do block([
            q:horner(ataylor(subst([eps=sqrt(eps2)],A1*(1-eps)-1),eps2,n)),
            linel:1200],
            print(concat(tab2,"case ",string(n),":")),
            print(concat(tab3,"t = ",string(q),";")),
            print(concat(tab3,"break;"))),
          print("    }
            return (t + eps) / (1 - eps);
        }"),
        'done)$

        maxpow:8$
        computeI1(maxpow)$
        codeA1(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;'
    */
    template <typename CT, std::size_t SeriesOrder>
    static inline CT evaluate_series_A1(CT eps)
    {
        CT eps2 = math::sqr(eps);
        CT t;
        switch (SeriesOrder/2) {
        case 0:
            t = CT(0);
            break;
        case 1:
            t = eps2/CT(4);
            break;
        case 2:
            t = eps2*(eps2+CT(16))/CT(64);
            break;
        case 3:
            t = eps2*(eps2*(eps2+CT(4))+CT(64))/CT(256);
            break;
        case 4:
            t = eps2*(eps2*(eps2*(CT(25)*eps2+CT(64))+CT(256))+CT(4096))/CT(16384);
            break;
        }
        return (t + eps) / (CT(1) - eps);
    }

    /*
     Generate and evaluate the series expansion of the following integral

     I2 = integrate( 1/sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )

     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2
     and expand (1 - eps) * I2 retaining terms up to order eps^maxpow
     in A2 and C2[l].

     The resulting series is of the form

     A2 * ( sigma + sum(C2[l] * sin(2*l*sigma), l, 1, maxpow) )

     The scale factor A2-1 = mean value of (d/dsigma)2 - 1

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_series_A2 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        computeI2(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],
          sintegrand:1/sqrt(1+k2*sin(sigma)^2),
          sintegrandexp:ataylor(
              (1+eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),
              eps,maxpow),
          s:trigreduce(integrate(sintegrandexp,sigma)),
          s:s-subst(sigma=0,s),
          A2:expand(subst(sigma=2*%pi,s)/(2*%pi)),
          tau1:ataylor(s/A2,eps,maxpow),
          for i:1 thru maxpow do C2[i]:coeff(tau1,sin(2*i*sigma)),
          if expand(tau1-sigma-sum(C2[i]*sin(2*i*sigma),i,1,maxpow)) # 0
          then error("left over terms in B2"),
          A2:A2/(1+eps),
          'done)$

        codeA2(maxpow):=block([tab2:"    ",tab3:"        "],
        print("// The scale factor A2-1 = mean value of (d/dsigma)I2 - 1
        CT evaluate_series_A2(CT const& eps)
        {
            CT const eps2 = math::sqr(eps);
            CT t;
            switch (SeriesOrder/2) {"),
          for n:0 thru entier(maxpow/2) do block([
            q:horner(ataylor(subst([eps=sqrt(eps2)],A2*(1+eps)-1),eps2,n)),
            linel:1200],
            print(concat(tab2,"case ",string(n),":")),
            print(concat(tab3,"t = ",string(q),";")),
            print(concat(tab3,"break;"))),
          print("    }
            return (t - eps) / (1 + eps);
        }"),
        'done)$

        maxpow:8$
        computeI2(maxpow)$
        codeA2(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;'
    */
    template <typename CT, std::size_t SeriesOrder>
    CT evaluate_series_A2(CT const& eps)
    {
        CT const eps2 = math::sqr(eps);
        CT t;
        switch (SeriesOrder/2) {
        case 0:
            t = CT(0);
            break;
        case 1:
            t = -CT(3)*eps2/CT(4);
            break;
        case 2:
            t = (-CT(7)*eps2-CT(48))*eps2/CT(64);
            break;
        case 3:
            t = eps2*((-CT(11)*eps2-CT(28))*eps2-CT(192))/CT(256);
            break;
        case 4:
            t = eps2*(eps2*((-CT(375)*eps2-CT(704))*eps2-CT(1792))-CT(12288))/CT(16384);
            break;
        }
        return (t - eps) / (CT(1) + eps);
    }

    /*
     Express

        I3 = integrate( (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma1)^2)), sigma1, 0, sigma )

     as a series

        A3 * ( sigma + sum(C3[l] * sin(2*l*sigma), l, 1, maxpow-1) )

     valid for f and k2 small.  It is convenient to write k2 = 4 * eps / (1 -
     eps)^2 and f = 2*n/(1+n) and expand in eps and n.  This procedure leads
     to a series where the coefficients of eps^j are terminating series in n.

     The scale factor A3 = mean value of (d/dsigma)I3

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_A3 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        computeI3(maxpow):=block([int,intexp,dlam,eta,del,eps,nu,f,z,n],
          maxpow:maxpow-1,
          int:subst([k2=4*eps/(1-eps)^2],
            (2-f)/(1+(1-f)*sqrt(1+k2*sin(sigma)^2))),
          int:subst([f=2*n/(1+n)],int),
          intexp:jtaylor(int,n,eps,maxpow),
          dlam:trigreduce(integrate(intexp,sigma)),
          dlam:dlam-subst(sigma=0,dlam),
          A3:expand(subst(sigma=2*%pi,dlam)/(2*%pi)),
          eta:jtaylor(dlam/A3,n,eps,maxpow),
          A3:jtaylor(A3,n,eps,maxpow),
          for i:1 thru maxpow do C3[i]:coeff(eta,sin(2*i*sigma)),
          if expand(eta-sigma-sum(C3[i]*sin(2*i*sigma),i,1,maxpow)) # 0
          then error("left over terms in B3"),
          'done)$

        codeA3(maxpow):=block([tab2:"    ",tab3:"        "],
        print("// The scale factor A3 = mean value of (d/dsigma)I3
        static inline void evaluate_series_A3(CT const& n, CT c[])
        {
            switch (SeriesOrder) {"),
          for nn:0 thru maxpow do block(
            [q:if nn=0 then 0 else
            jtaylor(subst([n=n],A3),n,eps,nn-1),
            linel:1200],
            print(concat(tab2,"case ",string(nn),":")),
            for i : 0 thru nn-1 do
            print(concat(tab3,"c[",i,"] = ",
                string(horner(coeff(q,eps,i))),";")),
            print(concat(tab3,"break;"))),
          print("    }
        }"),
        'done)$

        maxpow:8$
        computeI3(maxpow)$
        codeA3(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT(/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g'
    */
    // TODO: this produces different results that geographiclib
    template <typename CT, std::size_t SeriesOrder>
    static inline void evaluate_coeffs_A3(CT const& n, CT c[])
    {
        switch (SeriesOrder) {
        case 0:
            break;
        case 1:
            c[0] = CT(1);
            break;
        case 2:
            c[0] = CT(1);
            c[1] = -CT(1)/CT(2);
            break;
        case 3:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = -CT(1)/CT(4);
            break;
        case 4:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (-n-CT(2))/CT(8);
            c[3] = -CT(1)/CT(16);
            break;
        case 5:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (-CT(3)*n-CT(1))/CT(16);
            c[4] = -CT(3)/CT(64);
            break;
        case 6:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = ((-n-CT(3))*n-CT(1))/CT(16);
            c[4] = (-CT(2)*n-CT(3))/CT(64);
            c[5] = -CT(3)/CT(128);
            break;
        case 7:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);
            c[4] = ((-CT(10)*n-CT(2))*n-CT(3))/CT(64);
            c[5] = (-CT(5)*n-CT(3))/CT(128);
            c[6] = -CT(5)/CT(256);
            break;
        case 8:
            c[0] = CT(1);
            c[1] = (n-CT(1))/CT(2);
            c[2] = (n*(CT(3)*n-CT(1))-CT(2))/CT(8);
            c[3] = (n*(n*(CT(5)*n-CT(1))-CT(3))-CT(1))/CT(16);
            c[4] = (n*((-CT(5)*n-CT(20))*n-CT(4))-CT(6))/CT(128);
            c[5] = ((-CT(5)*n-CT(10))*n-CT(6))/CT(256);
            c[6] = (-CT(15)*n-CT(20))/CT(1024);
            c[7] = -CT(25)/CT(2048);
            break;
        }
    }

    /*
     The coefficients C1[l] in the Fourier expansion of B1.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C1 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        codeC1(maxpow):=block([tab2:"    ",tab3:"        "],
          print("// The coefficients C1[l] in the Fourier expansion of B1
        static inline evaluate_coeffs_C1(CT eps, CT c[]) {
            CT eps2 = math::sqr(eps);
            CT d = eps;
            switch (SeriesOrder) {"),
          for n:0 thru maxpow do (
            print(concat(tab2,"case ",string(n),":")),
            for m:1 thru n do block([q:d*horner(
                subst([eps=sqrt(eps2)],ataylor(C1[m],eps,n)/eps^m)),
              linel:1200],
              if m>1 then print(concat(tab3,"d *= eps;")),
              print(concat(tab3,"c[",string(m),"] = ",string(q),";"))),
            print(concat(tab3,"break;"))),
          print("    }
        }"),
        'done)$

        maxpow:8$
        computeI1(maxpow)$
        codeC1(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT(/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
               s/eps(CT(2))/eps2/g;'
    */
    template <typename CT, std::size_t SeriesOrder>
    static inline void evaluate_coeffs_C1(CT eps, CT c[])
    {
        CT eps2 = math::sqr(eps);
        CT d = eps;
        switch (SeriesOrder) {
        case 0:
            break;
        case 1:
            c[1] = -d/CT(2);
            break;
        case 2:
            c[1] = -d/CT(2);
            d *= eps;
            c[2] = -d/CT(16);
            break;
        case 3:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = -d/CT(16);
            d *= eps;
            c[3] = -d/CT(48);
            break;
        case 4:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = -d/CT(48);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            break;
        case 5:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            break;
        case 6:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            break;
        case 7:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            break;
        case 8:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*((CT(96)-CT(11)*eps2)*eps2-CT(160))/CT(16384);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = d*(CT(9)*eps2-CT(14))/CT(4096);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            d *= eps;
            c[8] = -CT(429)*d/CT(262144);
            break;
        }
    }

    /*
     The coefficients C1p[l] in the Fourier expansion of B1p.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C1p below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        revertI1(maxpow):=block([tau,eps,tauacc:1,sigacc:0],
          for n:1 thru maxpow do (
            tauacc:trigreduce(ataylor(
                  -sum(C1[j]*sin(2*j*tau),j,1,maxpow-n+1)*tauacc/n,
                  eps,maxpow)),
            sigacc:sigacc+expand(diff(tauacc,tau,n-1))),
          for i:1 thru maxpow do C1p[i]:coeff(sigacc,sin(2*i*tau)),
          if expand(sigacc-sum(C1p[i]*sin(2*i*tau),i,1,maxpow)) # 0
          then error("left over terms in B1p"),
          'done)$

        codeC1p(maxpow):=block([tab2:"    ",tab3:"        "],
          print("// The coefficients C1p[l] in the Fourier expansion of B1p
        static inline evaluate_coeffs_C1p(CT eps, CT c[])
        {
            CT const eps2 = math::sqr(eps);
            CT d = eps;
            switch (SeriesOrder) {"),
          for n:0 thru maxpow do (
            print(concat(tab2,"case ",string(n),":")),
            for m:1 thru n do block([q:d*horner(
                subst([eps=sqrt(eps2)],ataylor(C1p[m],eps,n)/eps^m)),
              linel:1200],
              if m>1 then print(concat(tab3,"d *= eps;")),
              print(concat(tab3,"c[",string(m),"] = ",string(q),";"))),
            print(concat(tab3,"break;"))),
          print("    }
        }"),
        'done)$

        maxpow:8$
        computeI1(maxpow)$
        revertI1(maxpow)$
        codeC1p(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT(/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
               s/eps(CT(2))/eps2/g;'
    */
    template <typename CT, std::size_t SeriesOrder>
    static inline void evaluate_coeffs_C1p(CT eps, CT c[])
    {
        CT const eps2 = math::sqr(eps);
        CT d = eps;
        switch (SeriesOrder) {
        case 0:
            break;
        case 1:
            c[1] = d/CT(2);
            break;
        case 2:
            c[1] = d/CT(2);
            d *= eps;
            c[2] = CT(5)*d/CT(16);
            break;
        case 3:
            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);
            d *= eps;
            c[2] = CT(5)*d/CT(16);
            d *= eps;
            c[3] = CT(29)*d/CT(96);
            break;
        case 4:
            c[1] = d*(CT(16)-CT(9)*eps2)/CT(32);
            d *= eps;
            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);
            d *= eps;
            c[3] = CT(29)*d/CT(96);
            d *= eps;
            c[4] = CT(539)*d/CT(1536);
            break;
        case 5:
            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);
            d *= eps;
            c[2] = d*(CT(30)-CT(37)*eps2)/CT(96);
            d *= eps;
            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);
            d *= eps;
            c[4] = CT(539)*d/CT(1536);
            d *= eps;
            c[5] = CT(3467)*d/CT(7680);
            break;
        case 6:
            c[1] = d*(eps2*(CT(205)*eps2-CT(432))+CT(768))/CT(1536);
            d *= eps;
            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);
            d *= eps;
            c[3] = d*(CT(116)-CT(225)*eps2)/CT(384);
            d *= eps;
            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);
            d *= eps;
            c[5] = CT(3467)*d/CT(7680);
            d *= eps;
            c[6] = CT(38081)*d/CT(61440);
            break;
        case 7:
            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);
            d *= eps;
            c[2] = d*(eps2*(CT(4005)*eps2-CT(4736))+CT(3840))/CT(12288);
            d *= eps;
            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);
            d *= eps;
            c[4] = d*(CT(2695)-CT(7173)*eps2)/CT(7680);
            d *= eps;
            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);
            d *= eps;
            c[6] = CT(38081)*d/CT(61440);
            d *= eps;
            c[7] = CT(459485)*d/CT(516096);
            break;
        case 8:
            c[1] = d*(eps2*((CT(9840)-CT(4879)*eps2)*eps2-CT(20736))+CT(36864))/CT(73728);
            d *= eps;
            c[2] = d*(eps2*((CT(120150)-CT(86171)*eps2)*eps2-CT(142080))+CT(115200))/CT(368640);
            d *= eps;
            c[3] = d*(eps2*(CT(8703)*eps2-CT(7200))+CT(3712))/CT(12288);
            d *= eps;
            c[4] = d*(eps2*(CT(1082857)*eps2-CT(688608))+CT(258720))/CT(737280);
            d *= eps;
            c[5] = d*(CT(41604)-CT(141115)*eps2)/CT(92160);
            d *= eps;
            c[6] = d*(CT(533134)-CT(2200311)*eps2)/CT(860160);
            d *= eps;
            c[7] = CT(459485)*d/CT(516096);
            d *= eps;
            c[8] = CT(109167851)*d/CT(82575360);
            break;
        }
    }

    /*
     The coefficients C2[l] in the Fourier expansion of B2.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C2 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        codeC2(maxpow):=block([tab2:"    ",tab3:"        "],
        print("// The coefficients C2[l] in the Fourier expansion of B2
        static inline void evaluate_coeffs_C2(CT const& eps, CT c[])
        {
            CT const eps2 = math::sqr(eps);
            CT d = eps;
            switch (SeriesOrder) {"),
          for n:0 thru maxpow do (
            print(concat(tab2,"case ",string(n),":")),
            for m:1 thru n do block([q:d*horner(
                subst([eps=sqrt(eps2)],ataylor(C2[m],eps,n)/eps^m)),
              linel:1200],
              if m>1 then print(concat(tab3,"d *= eps;")),
              print(concat(tab3,"c[",string(m),"] = ",string(q),";"))),
            print(concat(tab3,"break;"))),
        print("    }
        }"),
        'done)$

        maxpow:8$
        computeI2(maxpow)$
        codeC2(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT(/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
               s/eps(CT(2))/eps2/g;'
    */
    template <typename CT, std::size_t SeriesOrder>
    static inline void evaluate_coeffs_C2(CT const& eps, CT c[])
    {
        CT const eps2 = math::sqr(eps);
        CT d = eps;
        switch (SeriesOrder) {
        case 0:
            break;
        case 1:
            c[1] = d/CT(2);
            break;
        case 2:
            c[1] = d/CT(2);
            d *= eps;
            c[2] = CT(3)*d/CT(16);
            break;
        case 3:
            c[1] = d*(eps2+CT(8))/CT(16);
            d *= eps;
            c[2] = CT(3)*d/CT(16);
            d *= eps;
            c[3] = CT(5)*d/CT(48);
            break;
        case 4:
            c[1] = d*(eps2+CT(8))/CT(16);
            d *= eps;
            c[2] = d*(eps2+CT(6))/CT(32);
            d *= eps;
            c[3] = CT(5)*d/CT(48);
            d *= eps;
            c[4] = CT(35)*d/CT(512);
            break;
        case 5:
            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2+CT(6))/CT(32);
            d *= eps;
            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);
            d *= eps;
            c[4] = CT(35)*d/CT(512);
            d *= eps;
            c[5] = CT(63)*d/CT(1280);
            break;
        case 6:
            c[1] = d*(eps2*(eps2+CT(2))+CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);
            d *= eps;
            c[3] = d*(CT(15)*eps2+CT(80))/CT(768);
            d *= eps;
            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);
            d *= eps;
            c[5] = CT(63)*d/CT(1280);
            d *= eps;
            c[6] = CT(77)*d/CT(2048);
            break;
        case 7:
            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(CT(35)*eps2+CT(64))+CT(384))/CT(2048);
            d *= eps;
            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);
            d *= eps;
            c[4] = d*(CT(7)*eps2+CT(35))/CT(512);
            d *= eps;
            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);
            d *= eps;
            c[6] = CT(77)*d/CT(2048);
            d *= eps;
            c[7] = CT(429)*d/CT(14336);
            break;
        case 8:
            c[1] = d*(eps2*(eps2*(CT(41)*eps2+CT(64))+CT(128))+CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(eps2*(CT(47)*eps2+CT(70))+CT(128))+CT(768))/CT(4096);
            d *= eps;
            c[3] = d*(eps2*(CT(69)*eps2+CT(120))+CT(640))/CT(6144);
            d *= eps;
            c[4] = d*(eps2*(CT(133)*eps2+CT(224))+CT(1120))/CT(16384);
            d *= eps;
            c[5] = d*(CT(105)*eps2+CT(504))/CT(10240);
            d *= eps;
            c[6] = d*(CT(33)*eps2+CT(154))/CT(4096);
            d *= eps;
            c[7] = CT(429)*d/CT(14336);
            d *= eps;
            c[8] = CT(6435)*d/CT(262144);
            break;
        }
    }

    /*
     The coefficients C3[l] in the Fourier expansion of B3.

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_coeffs_C3 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        codeC3(maxpow):=block([tab2:"    ",tab3:"        "],
        print("// The coefficients C3[l] in the Fourier expansion of B3
        static inline void evaluate_coeffs_C3(CT const& n, CT c[])
        {
            const CT n2 = math::sqr(n);
            switch (SeriesOrder) {"),
          for nn:0 thru maxpow do block([c],
            print(concat(tab2,"case ",string(nn),":")),
            c:0,
            for m:1 thru nn-1 do block(
              [q:if nn = 0 then 0 else
              jtaylor(subst([n=n],C3[m]),_n,eps,nn-1),
              linel:1200],
              for j:m thru nn-1 do (
                print(concat(tab3,"c[",c,"] = ",
                    string(horner(coeff(q,eps,j))),";")),
                c:c+1)
            ),
            print(concat(tab3,"break;"))),
          print("    }
        }"),
        'done)$

        maxpow:8$
        computeI3(maxpow)$
        codeC3(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     script can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT(/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
               s/eps(CT(2))/eps2/g;'
    */
    template <typename CT, int SeriesOrder>
    void evaluate_coeffs_C3x(CT const& n, CT c[], const CT coeff[])
    {
        int offset = 0, k = 0;
        // l is index of C3[l].
        for (int l = 1; l < SeriesOrder; ++l)
        {
            for (int j = SeriesOrder - 1; j >= l; --j)
            {
                // Order of polynomial in n.
                int m = std::min(SeriesOrder - j - 1, j);
                c[k++] = math::polyval(m, coeff + offset, n) /
                coeff[offset + m + 1];
                offset += m + 2;
            }
        }
    }

    template <typename CT, int SeriesOrder>
    void evaluate_coeffs_C3x(CT const& n, CT c[]) {
        if (SeriesOrder == 3) {
            static const CT coeff[] = {
            // C3[1], coeff of eps^2, polynomial in n of order 0
            1, 8,
            // C3[1], coeff of eps^1, polynomial in n of order 1
            -1, 1, 4,
            // C3[2], coeff of eps^2, polynomial in n of order 0
            1, 16,
            };

            evaluate_coeffs_C3x<CT, SeriesOrder>(n, c, coeff);
        }
        else if (SeriesOrder == 4) {
            static const CT coeff[] = {
            // C3[1], coeff of eps^3, polynomial in n of order 0
            3, 64,
            // C3[1], coeff of eps^2, polynomial in n of order 1
            // This is a case where a leading 0 term has been inserted to maintain the
            // pattern in the orders of the polynomials.
            0, 1, 8,
            // C3[1], coeff of eps^1, polynomial in n of order 1
            -1, 1, 4,
            // C3[2], coeff of eps^3, polynomial in n of order 0
            3, 64,
            // C3[2], coeff of eps^2, polynomial in n of order 1
            -3, 2, 32,
            // C3[3], coeff of eps^3, polynomial in n of order 0
            5, 192,
            };

            evaluate_coeffs_C3x<CT, SeriesOrder>(n, c, coeff);
        }
        else if (SeriesOrder == 5) {
            static const CT coeff[] = {
            // C3[1], coeff of eps^4, polynomial in n of order 0
            5, 128,
            // C3[1], coeff of eps^3, polynomial in n of order 1
            3, 3, 64,
            // C3[1], coeff of eps^2, polynomial in n of order 2
            -1, 0, 1, 8,
            // C3[1], coeff of eps^1, polynomial in n of order 1
            -1, 1, 4,
            // C3[2], coeff of eps^4, polynomial in n of order 0
            3, 128,
            // C3[2], coeff of eps^3, polynomial in n of order 1
            -2, 3, 64,
            // C3[2], coeff of eps^2, polynomial in n of order 2
            1, -3, 2, 32,
            // C3[3], coeff of eps^4, polynomial in n of order 0
            3, 128,
            // C3[3], coeff of eps^3, polynomial in n of order 1
            -9, 5, 192,
            // C3[4], coeff of eps^4, polynomial in n of order 0
            7, 512,
            };

            evaluate_coeffs_C3x<CT, SeriesOrder>(n, c, coeff);
        }
        else if (SeriesOrder == 6) {
            static const CT coeff[] = {
            // C3[1], coeff of eps^5, polynomial in n of order 0
            3, 128,
            // C3[1], coeff of eps^4, polynomial in n of order 1
            2, 5, 128,
            // C3[1], coeff of eps^3, polynomial in n of order 2
            -1, 3, 3, 64,
            // C3[1], coeff of eps^2, polynomial in n of order 2
            -1, 0, 1, 8,
            // C3[1], coeff of eps^1, polynomial in n of order 1
            -1, 1, 4,
            // C3[2], coeff of eps^5, polynomial in n of order 0
            5, 256,
            // C3[2], coeff of eps^4, polynomial in n of order 1
            1, 3, 128,
            // C3[2], coeff of eps^3, polynomial in n of order 2
            -3, -2, 3, 64,
            // C3[2], coeff of eps^2, polynomial in n of order 2
            1, -3, 2, 32,
            // C3[3], coeff of eps^5, polynomial in n of order 0
            7, 512,
            // C3[3], coeff of eps^4, polynomial in n of order 1
            -10, 9, 384,
            // C3[3], coeff of eps^3, polynomial in n of order 2
            5, -9, 5, 192,
            // C3[4], coeff of eps^5, polynomial in n of order 0
            7, 512,
            // C3[4], coeff of eps^4, polynomial in n of order 1
            -14, 7, 512,
            // C3[5], coeff of eps^5, polynomial in n of order 0
            21, 2560,
            };

            evaluate_coeffs_C3x<CT, SeriesOrder>(n, c, coeff);
        }
        else if (SeriesOrder == 7) {
            static const CT coeff[] = {
            // C3[1], coeff of eps^6, polynomial in n of order 0
            21, 1024,
            // C3[1], coeff of eps^5, polynomial in n of order 1
            11, 12, 512,
            // C3[1], coeff of eps^4, polynomial in n of order 2
            2, 2, 5, 128,
            // C3[1], coeff of eps^3, polynomial in n of order 3
            -5, -1, 3, 3, 64,
            // C3[1], coeff of eps^2, polynomial in n of order 2
            -1, 0, 1, 8,
            // C3[1], coeff of eps^1, polynomial in n of order 1
            -1, 1, 4,
            // C3[2], coeff of eps^6, polynomial in n of order 0
            27, 2048,
            // C3[2], coeff of eps^5, polynomial in n of order 1
            1, 5, 256,
            // C3[2], coeff of eps^4, polynomial in n of order 2
            -9, 2, 6, 256,
            // C3[2], coeff of eps^3, polynomial in n of order 3
            2, -3, -2, 3, 64,
            // C3[2], coeff of eps^2, polynomial in n of order 2
            1, -3, 2, 32,
            // C3[3], coeff of eps^6, polynomial in n of order 0
            3, 256,
            // C3[3], coeff of eps^5, polynomial in n of order 1
            -4, 21, 1536,
            // C3[3], coeff of eps^4, polynomial in n of order 2
            -6, -10, 9, 384,
            // C3[3], coeff of eps^3, polynomial in n of order 3
            -1, 5, -9, 5, 192,
            // C3[4], coeff of eps^6, polynomial in n of order 0
            9, 1024,
            // C3[4], coeff of eps^5, polynomial in n of order 1
            -10, 7, 512,
            // C3[4], coeff of eps^4, polynomial in n of order 2
            10, -14, 7, 512,
            // C3[5], coeff of eps^6, polynomial in n of order 0
            9, 1024,
            // C3[5], coeff of eps^5, polynomial in n of order 1
            -45, 21, 2560,
            // C3[6], coeff of eps^6, polynomial in n of order 0
            11, 2048,
            };

            evaluate_coeffs_C3x<CT, SeriesOrder>(n, c, coeff);
        }
        else if (SeriesOrder == 8) {
            static const CT coeff[] = {
            // C3[1], coeff of eps^7, polynomial in n of order 0
            243, 16384,
            // C3[1], coeff of eps^6, polynomial in n of order 1
            10, 21, 1024,
            // C3[1], coeff of eps^5, polynomial in n of order 2
            3, 11, 12, 512,
            // C3[1], coeff of eps^4, polynomial in n of order 3
            -2, 2, 2, 5, 128,
            // C3[1], coeff of eps^3, polynomial in n of order 3
            -5, -1, 3, 3, 64,
            // C3[1], coeff of eps^2, polynomial in n of order 2
            -1, 0, 1, 8,
            // C3[1], coeff of eps^1, polynomial in n of order 1
            -1, 1, 4,
            // C3[2], coeff of eps^7, polynomial in n of order 0
            187, 16384,
            // C3[2], coeff of eps^6, polynomial in n of order 1
            69, 108, 8192,
            // C3[2], coeff of eps^5, polynomial in n of order 2
            -2, 1, 5, 256,
            // C3[2], coeff of eps^4, polynomial in n of order 3
            -6, -9, 2, 6, 256,
            // C3[2], coeff of eps^3, polynomial in n of order 3
            2, -3, -2, 3, 64,
            // C3[2], coeff of eps^2, polynomial in n of order 2
            1, -3, 2, 32,
            // C3[3], coeff of eps^7, polynomial in n of order 0
            139, 16384,
            // C3[3], coeff of eps^6, polynomial in n of order 1
            -1, 12, 1024,
            // C3[3], coeff of eps^5, polynomial in n of order 2
            -77, -8, 42, 3072,
            // C3[3], coeff of eps^4, polynomial in n of order 3
            10, -6, -10, 9, 384,
            // C3[3], coeff of eps^3, polynomial in n of order 3
            -1, 5, -9, 5, 192,
            // C3[4], coeff of eps^7, polynomial in n of order 0
            127, 16384,
            // C3[4], coeff of eps^6, polynomial in n of order 1
            -43, 72, 8192,
            // C3[4], coeff of eps^5, polynomial in n of order 2
            -7, -40, 28, 2048,
            // C3[4], coeff of eps^4, polynomial in n of order 3
            -7, 20, -28, 14, 1024,
            // C3[5], coeff of eps^7, polynomial in n of order 0
            99, 16384,
            // C3[5], coeff of eps^6, polynomial in n of order 1
            -15, 9, 1024,
            // C3[5], coeff of eps^5, polynomial in n of order 2
            75, -90, 42, 5120,
            // C3[6], coeff of eps^7, polynomial in n of order 0
            99, 16384,
            // C3[6], coeff of eps^6, polynomial in n of order 1
            -99, 44, 8192,
            // C3[7], coeff of eps^7, polynomial in n of order 0
            429, 114688,
            };

            evaluate_coeffs_C3x<CT, SeriesOrder>(n, c, coeff);
        }
        // Post condition: offset == sizeof(coeff) / sizeof(CT) && k == coeffs_C3_size
    }

    /*
    \brief Given the set of coefficients coeffs2[] evaluate on
      C3 and return the set of coefficients coeffs1[].

      Elements coeffs1[1] through coeffs1[SeriesOrder - 1] are set.
    */
    template <typename CT, size_t SeriesOrder>
    static inline void evaluate_coeffs_C3(CT eps, CT coeffs1[], CT coeffs2[])
    {
        CT mult = 1;
        int offset = 0;

        // l is the index of C3[l].
        for (size_t l = 1; l < SeriesOrder; ++l)
        {
            // Order of polynomial in eps.
            int m = SeriesOrder - l - 1;
            mult *= eps;
            coeffs1[l] = mult * math::polyval(m, coeffs2 + offset, eps);
            offset += m + 1;
        }
        // Post condition: offset == coeffs_C3_size
    }


}}} // namespace boost::geometry::series_expansion

#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
