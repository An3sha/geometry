// Boost.Geometry

// Use, modification and distribution is subject to the Boost Software License,
// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
#define BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP

#include <boost/geometry/util/math.hpp>

namespace boost { namespace geometry { namespace series_expansion {

    /*
     Generate and evaluate the series expansion of the following integral

     I1 = integrate( sqrt(1+k2*sin(sigma1)^2), sigma1, 0, sigma )

     which is valid for k2 small. We substitute k2 = 4 * eps / (1 - eps)^2
     and expand (1 - eps) * I1 retaining terms up to order eps^maxpow
     in A1 and C1[l].

     The resulting series is of the form

     A1 * ( sigma + sum(C1[l] * sin(2*l*sigma), l, 1, maxpow) ).

     The scale factor A1-1 = mean value of (d/dsigma)I1 - 1

     The expansion above is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_series_A1 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        taylordepth:5$
        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$
        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],
        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$

        computeintegral(maxpow):=block([sintegrand,sintegrandexp,s,sigma,tau1,k2,eps],
          sintegrand:sqrt(1+k2*sin(sigma)^2),
          sintegrandexp:ataylor(
              (1-eps)*subst([k2=4*eps/(1-eps)^2],sintegrand),
              eps,maxpow),
          s:trigreduce(integrate(sintegrandexp,sigma)),
          s:s-subst(sigma=0,s),
          A1:expand(subst(sigma=2*%pi,s)/(2*%pi)),
          tau1:ataylor(s/A1,eps,maxpow),
          for i:1 thru maxpow do C1[i]:coeff(tau1,sin(2*i*sigma)),
          if expand(tau1-sigma-sum(C1[i]*sin(2*i*sigma),i,1,maxpow)) # 0
          then error("left over terms in B1"),
          A1:A1/(1-eps),
          'done)$

        generatecode(maxpow):=block([tab2:"    ",tab3:"        "],
        print("// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1
        static inline CT evaluate_series_A1(CT eps) {
            CT eps2 = math::sqr(eps);
            CT t;
            switch (SeriesOrder/2) {"),
          for n:0 thru entier(maxpow/2) do block([
            q:horner(ataylor(subst([eps=sqrt(eps2)],A1*(1-eps)-1),eps2,n)),
            linel:1200],
            print(concat(tab2,"case ",string(n),":")),
            print(concat(tab3,"t = ",string(q),";")),
            print(concat(tab3,"break;"))),
          print("    }
            return (t + eps) / (1 - eps);
        }"),
        'done)$

        maxpow:8$
        computeintegral(maxpow)$
        generatecode(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     scirpt can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;'
    */
    template <typename CT, std::size_t SeriesOrder>
    static inline CT evaluate_series_A1(CT eps)
    {
        CT eps2 = math::sqr(eps);
        CT t;
        switch (SeriesOrder/2) {
        case 0:
            t = CT(0);
            break;
        case 1:
            t = eps2/CT(4);
            break;
        case 2:
            t = eps2*(eps2+CT(16))/CT(64);
            break;
        case 3:
            t = eps2*(eps2*(eps2+CT(4))+CT(64))/CT(256);
            break;
        case 4:
            t = eps2*(eps2*(eps2*(CT(25)*eps2+CT(64))+CT(256))+CT(4096))/CT(16384);
            break;
        }
        return (t + eps) / (CT(1) - eps);
    }

    /*
     The coefficients C1[l] in the Fourier expansion of B1

     The expansion below is performed in Maxima, a Computer Algebra System.
     The C++ code (that yields the function evaluate_series_A1 below) is
     generated by the following Maxima script and is based on script:
     http://geographiclib.sourceforge.net/html/geod.mac

        // Maxima script begin
        taylordepth:5$
        ataylor(expr,var,ord):=expand(ratdisrep(taylor(expr,var,0,ord)))$
        jtaylor(expr,var1,var2,ord):=block([zz],expand(subst([zz=1],
        ratdisrep(taylor(subst([var1=zz*var1,var2=zz*var2],expr),zz,0,ord)))))$

        generatecode(maxpow):=block([tab2:"    ",tab3:"        "],
          print("// The coefficients C1[l] in the Fourier expansion of B1
        static inline evaluate_coeffs_C1(CT eps, CT c[]) {
            CT eps2 = math::sqr(eps);
            CT d = eps;
            switch (SeriesOrder) {"),
          for n:0 thru maxpow do (
            print(concat(tab2,"case ",string(n),":")),
            for m:1 thru n do block([q:d*horner(
                subst([eps=sqrt(eps2)],ataylor(C1[m],eps,n)/eps^m)),
              linel:1200],
              if m>1 then print(concat(tab3,"d *= eps;")),
              print(concat(tab3,"c[",string(m),"] = ",string(q),";"))),
            print(concat(tab3,"break;"))),
          print("    }
        }"),
        'done)$

        maxpow:8$
        computeintegral(maxpow)$
        generatecode(maxpow)$
        // Maxima script end

     To replace each number x by CT(x) the following
     scirpt can be used:
       sed -e 's/[0-9]\+/CT(&)/g; s/\[CT(/\[/g; s/)\]/\]/g;
               s/case\sCT(/case /g; s/):/:/g; s/epsCT(2)/eps2/g;
               s/eps(CT(2))/eps2/g;'
    */
    template <typename CT, std::size_t SeriesOrder>
    static inline void evaluate_coeffs_C1(CT eps, CT c[])
    {
        CT eps2 = math::sqr(eps);
        CT d = eps;
        switch (SeriesOrder) {
        case 0:
            break;
        case 1:
            c[1] = -d/CT(2);
            break;
        case 2:
            c[1] = -d/CT(2);
            d *= eps;
            c[2] = -d/CT(16);
            break;
        case 3:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = -d/CT(16);
            d *= eps;
            c[3] = -d/CT(48);
            break;
        case 4:
            c[1] = d*(CT(3)*eps2-CT(8))/CT(16);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = -d/CT(48);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            break;
        case 5:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*(eps2-CT(2))/CT(32);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = -CT(5)*d/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            break;
        case 6:
            c[1] = d*((CT(6)-eps2)*eps2-CT(16))/CT(32);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*(CT(9)*eps2-CT(16))/CT(768);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = -CT(7)*d/CT(1280);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            break;
        case 7:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*((CT(64)-CT(9)*eps2)*eps2-CT(128))/CT(2048);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*(CT(3)*eps2-CT(5))/CT(512);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = -CT(7)*d/CT(2048);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            break;
        case 8:
            c[1] = d*(eps2*(eps2*(CT(19)*eps2-CT(64))+CT(384))-CT(1024))/CT(2048);
            d *= eps;
            c[2] = d*(eps2*(eps2*(CT(7)*eps2-CT(18))+CT(128))-CT(256))/CT(4096);
            d *= eps;
            c[3] = d*((CT(72)-CT(9)*eps2)*eps2-CT(128))/CT(6144);
            d *= eps;
            c[4] = d*((CT(96)-CT(11)*eps2)*eps2-CT(160))/CT(16384);
            d *= eps;
            c[5] = d*(CT(35)*eps2-CT(56))/CT(10240);
            d *= eps;
            c[6] = d*(CT(9)*eps2-CT(14))/CT(4096);
            d *= eps;
            c[7] = -CT(33)*d/CT(14336);
            d *= eps;
            c[8] = -CT(429)*d/CT(262144);
            break;
        }
    }

}}} // namespace boost::geometry::formula

#endif // BOOST_GEOMETRY_UTIL_SERIES_EXPANSION_HPP
